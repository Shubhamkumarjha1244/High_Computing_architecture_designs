`timescale 1ns / 1ps
//////////////////////////////////////////////////////////////////////////////////
// Company: iit patna
// Engineer: shubham kumar jha
// 
// Create Date: 07.02.2025 10:30:03
// Design Name: 
// Module Name: booth_algo
// Project Name: 
// Target Devices: 
// Tool Versions: 
// Description: 
// 
// Dependencies: 
// 
// Revision:
// Revision 0.01 - File Created
// Additional Comments:
// 
//////////////////////////////////////////////////////////////////////////////////


module full_adder(inn1,inn2,carry_in,sum,carry_out);
    input inn1,inn2,carry_in;    //taken 2 input & carry_in wire for fulladder input
    output sum,carry_out; //taken output of sum,carry 
    
    assign sum=inn1^inn2^carry_in; //use concatenation operator for sum& carry_out generation
    assign carry_out=(inn1 & inn2)|(inn2 & carry_in)|(inn1 & carry_in);
endmodule

module two_one_mux(inn1,inn2,sel,out);
    input inn1,inn2,sel; //input for mux & select line
    output out; //output for mux
    assign out=sel?inn2:inn1; //use terninary operator for mux operation
endmodule

module one_bit_carry_select_adder(inn1,inn2,carry_in,sum,carry_out);
    input inn1,inn2,carry_in;
    output sum,carry_out;
    wire internal_sum1,internal_sum2,internal_carry1,internal_carry2;  //for internal sum & carry generated by full adder module
    
    full_adder full_adder_1(inn1,inn2,1'b0,internal_sum1,internal_carry1); //imported full adder module & connect it
    full_adder full_adder_2(inn1,inn2,1'b1,internal_sum2,internal_carry2);//imported full adder module & connect it
    
    two_one_mux mux1(internal_carry1,internal_carry2,carry_in,carry_out);//imported mux module & connect it
    two_one_mux mux2(internal_sum1,internal_sum2,carry_in,sum);//imported mux module & connect it
    
endmodule



module n_bit_carry_select_adder(innA,innB,control,sum);
    parameter   number_of_adder=32;
    input [number_of_adder-1:0] innA,innB;
    input control;
    output[number_of_adder-1:0] sum;
    
    wire [number_of_adder-1:0] xor_inn2;
    wire[number_of_adder:0] int_carry;  //internal_carry function
    
    assign int_carry[0]=control;
    
    

    genvar i;


    generate    for(i=0;i<number_of_adder;i=i+1)
        begin: byte_adder //name of block
            //initialization of 32 1B carry select Adder using generate
            assign xor_inn2[i]=innB[i]^control;     //2'S complement block
            one_bit_carry_select_adder add(innA[i],xor_inn2[i],int_carry[i],sum[i],int_carry[i+1]); //import 1 bit carry
            
        end
    
    endgenerate     

endmodule


module n_bit_two_one_mux(inn1,inn2,sel,out);
    parameter size=32;
    input[size-1:0] inn1,inn2; // size-1 bit input
    input sel; //select line
    output[size-1:0] out; //output
    
    assign out=sel?inn2:inn1;//mux initialization
    
    
endmodule












module booth_multiplier_n_bit_functional(clk,rst,multiplier,multiplicand,product);
    parameter size=32; //size of multiplier & multiplicant
    input   clk,rst; //control signal port
    input[size-1:0] multiplier,multiplicand; //input
    output reg [(2*size)-1:0] product; //output
    reg[size-1:0] count=0;//counter for passing final_output only
    reg[size-1:0] ppr=0; //internal ppr registor
    reg[size-1:0] multiplier_reg=0; //multiplier register
    reg lsb=0; //1 bit registor
    
    wire [size-1:0] adder_substractor_out; //output of adder_substractor block
    wire [size-1:0] ppr_wire;   //output of mux
    wire mux_select; //select line for mux
    
    
    
    n_bit_carry_select_adder adder_substractor(ppr,multiplicand,multiplier_reg[0],adder_substractor_out); //adder_substractor block initialization
    xor xor1(mux_select,lsb,multiplier_reg[0]); //xor block initialization
    n_bit_two_one_mux mux(ppr,adder_substractor_out,mux_select,ppr_wire); //mux block initialization
     
     
    always @(posedge clk) //initial assignment in registors
        if(rst)
            begin
                multiplier_reg=multiplier; 
                ppr=0;
                lsb=0;
            end
            
    always @(negedge clk)  
                begin
                count=count+1;//counter increment
                ppr=ppr_wire; //value assignment in reg block from wire with clock
                {ppr,multiplier_reg,lsb}={ppr[size-1],ppr,multiplier_reg}; // arthemetic right shifting with control signal
                if(count==size) 
                    product={ppr,multiplier};
                end 

endmodule